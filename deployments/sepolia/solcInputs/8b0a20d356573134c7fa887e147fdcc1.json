{
  "language": "Solidity",
  "sources": {
    "contracts/EnergyMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ncontract EnergyMarket {\n    // State Variables\n    string public constant NAME = \"NRG Token\";\n    string public constant SYMBOL = \"NRG\";\n    string public constant STANDARD = \"NRG Token v1.0\";\n    uint8 public constant DECIMALS = 18;\n    uint256 internal constant INITIAL_SUPPLY =\n        10000000 * (10 ** uint256(DECIMALS));\n    uint256 internal _totalSupply;\n    address public immutable DSO;\n\n    // Events\n    event Transfer(\n        address indexed _from,\n        address indexed _to,\n        uint256 _value,\n        uint256 balanceOfSender,\n        uint256 balanceOfReciever\n    );\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n\n    // Mappings\n    mapping(address => uint256) internal balances;\n    mapping(address => mapping(address => uint256)) internal allowed;\n\n    // Constructor\n    constructor() {\n        _totalSupply = INITIAL_SUPPLY;\n        balances[msg.sender] = INITIAL_SUPPLY;\n        emit Transfer(\n            address(0),\n            msg.sender,\n            INITIAL_SUPPLY,\n            balances[address(0)],\n            balances[msg.sender]\n        );\n        DSO = msg.sender;\n    }\n\n    // Functions\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function transfer(\n        address _to,\n        uint256 _value\n    ) public returns (bool success) {\n        if (_to == address(0)) revert(\"Invalid address\");\n        if (_value > balances[msg.sender]) revert(\"Insufficient balance\");\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(\n            msg.sender,\n            _to,\n            _value,\n            balances[msg.sender],\n            balances[_to]\n        );\n        return true;\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public returns (bool success) {\n        if (_to == address(0)) revert(\"Invalid address\");\n        if (_value > balances[_from]) revert(\"Insufficient balance\");\n        if (_value > allowed[_from][msg.sender])\n            revert(\"Insufficient allowance\");\n        balances[_from] -= _value;\n        balances[_to] += _value;\n        allowed[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value, balances[_from], balances[_to]);\n        return true;\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    ) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    ) public returns (bool success) {\n        allowed[msg.sender][_spender] += _addedValue;\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    ) public returns (bool success) {\n        uint256 oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue - _subtractedValue;\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    // State Variables\n    uint256 public totalEnergySupplied;\n    uint256 public totalEnergyDemanded;\n    uint256 public totalUsers;\n    uint256 internal etime;\n    uint256 internal supplyIndex;\n    uint256 internal demandIndex;\n    uint256 public constant MAX_ENERGYPRICE = 500 * (10 ** uint256(DECIMALS));\n\n    // Enum\n    enum EnergyState {\n        Register, // 0\n        Injected, // 1\n        Board, // 2\n        Match, // 3\n        Purchased // 4\n    }\n\n    // Structures\n    struct EnergyOwnership {\n        address addrOwner;\n        uint256 energyAmount;\n        uint256 energyState;\n        uint256 timestamp;\n    }\n    struct Supply {\n        address addrProsumer;\n        uint256 energySupplied;\n    }\n    struct Demand {\n        address addrConsumer;\n        uint256 energyDemanded;\n    }\n    struct EnergyMatched {\n        address addrProsumer;\n        address addrConsumer;\n        uint256 energyAmount;\n        uint256 timestamp;\n    }\n\n    // Mappings\n    mapping(address => uint256) internal addrIndex;\n\n    // Arrays\n    EnergyOwnership[][] public energys;\n    EnergyOwnership[] internal energy;\n    Supply[] public supplies;\n    Demand[] public demands;\n    EnergyMatched[] public matches;\n\n    // Events\n    event Gen(uint256 gen);\n    event EnergyCheck(\n        address addrOwner,\n        uint256 energyAmount,\n        uint256 energyState,\n        uint256 timestamp\n    );\n    event RoundStart(uint256 stime, uint256 etime);\n    event SellRequestCheck(address addr, uint256 amount);\n    event BuyRequestCheck(address addr, uint256 amount);\n    event EnergyMatchedCheck(\n        address addrProsumer,\n        address addrConsumer,\n        uint256 value,\n        uint256 timestamp\n    );\n\n    // Functions\n    // Round Start\n    function roundStart() public {\n        if (msg.sender != DSO) revert(\"Only DSO can start the round\");\n        uint256 stime = block.timestamp;\n        etime = stime + 1 hours;\n        totalEnergyDemanded = 0;\n        totalEnergySupplied = 0;\n        emit RoundStart(stime, etime);\n    }\n\n    // Register\n    function register() public {\n        addrIndex[msg.sender] = totalUsers;\n        EnergyOwnership memory _energy = EnergyOwnership(\n            msg.sender,\n            0,\n            uint256(EnergyState.Register),\n            block.timestamp\n        );\n        energy.push(_energy);\n        energys.push(energy);\n\n        emit EnergyCheck(\n            energys[totalUsers][0].addrOwner,\n            energys[totalUsers][0].energyAmount,\n            energys[totalUsers][0].energyState,\n            energys[totalUsers][0].timestamp\n        );\n        totalUsers++;\n        delete energy;\n    }\n\n    // Inject Energy (Ei)\n    function inject(address _owner, uint256 _amount) public {\n        if (msg.sender != DSO) revert(\"Only DSO can inject energy\");\n        if (\n            energys[addrIndex[_owner]][0].energyState !=\n            uint256(EnergyState.Register)\n        ) revert(\"Energy is not registered\");\n\n        EnergyOwnership memory _energy = EnergyOwnership(\n            _owner,\n            _amount,\n            uint256(EnergyState.Injected),\n            block.timestamp\n        );\n        uint256 i = addrIndex[_owner];\n        energys[i].push(_energy);\n        uint256 j = energys[i].length - 1;\n\n        emit EnergyCheck(\n            energys[i][j].addrOwner,\n            energys[i][j].energyAmount,\n            energys[i][j].energyState,\n            energys[i][j].timestamp\n        );\n\n        // Aggregation\n        if (j != 1) {\n            energys[i][1].energyAmount += energys[i][j].energyAmount;\n            energys[i][1].timestamp = block.timestamp;\n            energys[i].pop();\n        }\n        emit Gen(0);\n    }\n\n    // Request to sell amount of intent to sell (Si)\n    function requestSell(uint256 _amount) public {\n        uint256 i = addrIndex[msg.sender];\n        if (energys[i][1].energyAmount < _amount) revert(\"Not enough energy\");\n        if (block.timestamp > etime) revert(\"Not in round time\");\n\n        EnergyOwnership memory _energy = EnergyOwnership(\n            msg.sender,\n            _amount,\n            uint256(EnergyState.Board),\n            block.timestamp\n        );\n        energys[i].push(_energy);\n        energys[i][1].energyAmount -= _amount;\n\n        Supply memory _supply = Supply(msg.sender, _amount);\n        supplies.push(_supply);\n        supplyIndex++;\n        totalEnergySupplied += _amount;\n\n        emit SellRequestCheck(msg.sender, _amount);\n    }\n\n    // Request to buy amount of intent to buy (Di)\n    function requestBuy(uint256 _amount) public {\n        if (_amount == 0) revert(\"Amount cannot be zero\");\n        if (_amount * MAX_ENERGYPRICE > balanceOf(msg.sender))\n            revert(\"Not enough tokens\");\n        if (block.timestamp > etime) revert(\"Round is over\");\n\n        uint256 i = addrIndex[msg.sender];\n        EnergyOwnership memory _energy = EnergyOwnership(\n            msg.sender,\n            _amount,\n            uint256(EnergyState.Board),\n            block.timestamp\n        );\n        energys[i].push(_energy);\n\n        Demand memory demand = Demand(msg.sender, _amount);\n        demands.push(demand);\n        demandIndex++;\n        totalEnergyDemanded += _amount;\n\n        decreaseApproval(DSO, balanceOf(msg.sender));\n        approve(DSO, _amount * MAX_ENERGYPRICE);\n\n        emit BuyRequestCheck(msg.sender, _amount);\n    }\n\n    // Match\n    function matching() public {\n        etime = block.timestamp;\n        // q - Demand/Supply Ratio\n        uint256 q = 1;\n        uint256 tradedSupplyIndex;\n        uint256 tradedDemandIndex;\n\n        if (totalEnergySupplied > totalEnergyDemanded) {\n            q = (totalEnergyDemanded * 100) / totalEnergySupplied;\n\n            // Setting matched (actually sold) energy (Smi)\n            for (uint256 i = 0; i < supplyIndex; i++) {\n                supplies[i].energySupplied =\n                    (supplies[i].energySupplied * q) /\n                    100;\n\n                uint256 addr_i = addrIndex[supplies[i].addrProsumer];\n                uint256 j = energys[addr_i].length - 1;\n                energys[addr_i][1].energyAmount +=\n                    energys[addr_i][j].energyAmount -\n                    (energys[addr_i][j].energyAmount * q) /\n                    100;\n                energys[addr_i][1].timestamp = block.timestamp;\n                energys[addr_i][j].energyAmount =\n                    (energys[addr_i][j].energyAmount * q) /\n                    100;\n                energys[addr_i][j].energyState = uint256(EnergyState.Match);\n                energys[addr_i][j].timestamp = block.timestamp;\n            }\n        } else if (totalEnergySupplied < totalEnergyDemanded) {\n            q = (totalEnergySupplied * 100) / totalEnergyDemanded;\n\n            // Setting matched (actually bought) energy (Dmi)\n            for (uint256 i = 0; i < demandIndex; i++) {\n                demands[i].energyDemanded =\n                    (demands[i].energyDemanded * q) /\n                    100;\n                energys[addrIndex[demands[i].addrConsumer]][1]\n                    .energyAmount = demands[i].energyDemanded;\n                energys[addrIndex[demands[i].addrConsumer]][1]\n                    .energyState = uint256(EnergyState.Match);\n                energys[addrIndex[demands[i].addrConsumer]][1].timestamp = block\n                    .timestamp;\n            }\n        }\n\n        // Getting energySupplied and energyDemanded\n        uint256 sellingAmount = supplies[tradedSupplyIndex].energySupplied;\n        uint256 buyingAmount = demands[tradedDemandIndex].energyDemanded;\n\n        // Matching\n        do {\n            if (sellingAmount > buyingAmount) {\n                // Matching buyingAmount of energy\n                sellingAmount -= buyingAmount;\n                EnergyMatched memory _match = EnergyMatched(\n                    supplies[tradedSupplyIndex].addrProsumer,\n                    demands[tradedDemandIndex].addrConsumer,\n                    buyingAmount,\n                    block.timestamp\n                );\n                matches.push(_match);\n                emit EnergyMatchedCheck(\n                    _match.addrProsumer,\n                    _match.addrConsumer,\n                    _match.energyAmount,\n                    _match.timestamp\n                );\n                tradedDemandIndex++;\n                if (tradedDemandIndex >= demandIndex) break;\n                buyingAmount = demands[tradedDemandIndex].energyDemanded;\n            } else if (sellingAmount < buyingAmount) {\n                // Matching sellingAmount of energy\n                buyingAmount -= sellingAmount;\n                EnergyMatched memory _match = EnergyMatched(\n                    supplies[tradedSupplyIndex].addrProsumer,\n                    demands[tradedDemandIndex].addrConsumer,\n                    sellingAmount,\n                    block.timestamp\n                );\n                matches.push(_match);\n                emit EnergyMatchedCheck(\n                    _match.addrProsumer,\n                    _match.addrConsumer,\n                    _match.energyAmount,\n                    _match.timestamp\n                );\n                tradedSupplyIndex++;\n                if (tradedSupplyIndex >= supplyIndex) break;\n                sellingAmount = supplies[tradedSupplyIndex].energySupplied;\n            } else {\n                // Matching equal energy\n                EnergyMatched memory _match = EnergyMatched(\n                    supplies[tradedSupplyIndex].addrProsumer,\n                    demands[tradedDemandIndex].addrConsumer,\n                    sellingAmount,\n                    block.timestamp\n                );\n                matches.push(_match);\n                emit EnergyMatchedCheck(\n                    _match.addrProsumer,\n                    _match.addrConsumer,\n                    _match.energyAmount,\n                    _match.timestamp\n                );\n                tradedSupplyIndex++;\n                tradedDemandIndex++;\n                if (tradedSupplyIndex >= supplyIndex) break;\n                if (tradedDemandIndex >= demandIndex) break;\n                sellingAmount = supplies[tradedSupplyIndex].energySupplied;\n                buyingAmount = demands[tradedDemandIndex].energyDemanded;\n            }\n        } while (true);\n\n        for (uint256 i = 0; i < totalUsers; i++) {\n            for (uint256 j = energys[i].length - 1; j > 1; j--) {\n                if (energys[i][j].energyAmount == 0) {\n                    for (uint256 k = j; k < energys[i].length - 1; k++) {\n                        energys[i][k] = energys[i][k + 1];\n                    }\n                    energys[i].pop();\n                }\n            }\n        }\n\n        emit Gen(0);\n    }\n\n    // Trade\n    function trade(uint256 _price) public {\n        if (msg.sender != DSO) revert(\"Only DSO can trade\");\n        uint256 price = _price;\n\n        for (uint256 i = 0; i < matches.length; i++) {\n            transferFrom(\n                matches[i].addrConsumer,\n                matches[i].addrProsumer,\n                matches[i].energyAmount * price\n            );\n            energys[addrIndex[matches[i].addrConsumer]][1]\n                .energyAmount = matches[i].energyAmount;\n            energys[addrIndex[matches[i].addrConsumer]][1]\n                .energyState = uint256(EnergyState.Purchased);\n            energys[addrIndex[matches[i].addrConsumer]][1].timestamp = block\n                .timestamp;\n        }\n        delete matches;\n        emit Gen(0);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}