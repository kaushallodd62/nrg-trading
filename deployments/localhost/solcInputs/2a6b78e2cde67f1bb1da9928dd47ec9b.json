{
  "language": "Solidity",
  "sources": {
    "contracts/EnergyMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n// Errors\nerror EnergyMarket__InsufficientBalance(uint256 balance, uint256 required);\nerror EnergyMarket__InsufficientAllowance(uint256 allowance, uint256 required);\nerror EnergyMarket__InvalidAddress(address addr);\nerror EnergyMarket__NotDSO(address addr);\nerror EnergyMarket__InsufficientEnergyInjected(\n    uint256 energyAmount,\n    uint256 required\n);\nerror EnergyMarket__OutsideRound(\n    uint256 currentTime,\n    uint256 startTime,\n    uint256 endTime\n);\nerror EnergyMarket__ZeroEnergyAmount();\n\n/**\n * @title A smart contract for Energy Trading\n * @author Kaushal Lodd\n * @notice  This contract generates and controls circulation of NRGTokens for facilitating energy trading. It also simulates an energy market where users can register, prosumers can inject energy and supply energy, consumers can demand energy, and the energy market can match the prosumers and consumers based on their energy s_demands and s_supplies.\n * @dev This contract is deployed by the i_DSO who plays a crucial role in the energy market. The Matching algoritm s_matches the prosumers and consumers automatically.\n */\ncontract EnergyMarket {\n    // State Variables\n    string public constant NAME = \"NRG Token\";\n    string public constant SYMBOL = \"NRG\";\n    string public constant STANDARD = \"NRG Token v1.0\";\n    uint8 public constant DECIMALS = 18;\n    uint256 private constant INITIAL_SUPPLY =\n        10000000 * (10 ** uint256(DECIMALS));\n    uint256 private s_totalSupply;\n    address private immutable i_DSO;\n\n    // Mappings\n    mapping(address => uint256) private s_balances;\n    mapping(address => mapping(address => uint256)) private s_allowed;\n\n    // Events\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n\n    // Constructor\n    constructor() {\n        i_DSO = msg.sender;\n        s_totalSupply = INITIAL_SUPPLY;\n        s_balances[msg.sender] = INITIAL_SUPPLY;\n        emit Transfer(address(0), msg.sender, INITIAL_SUPPLY);\n    }\n\n    // Functions\n    function totalSupply() public view returns (uint256) {\n        return s_totalSupply;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return s_balances[_owner];\n    }\n\n    function transfer(\n        address _to,\n        uint256 _value\n    ) public returns (bool success) {\n        if (_to == address(0)) revert EnergyMarket__InvalidAddress(_to);\n        if (_value > s_balances[msg.sender])\n            revert EnergyMarket__InsufficientBalance({\n                balance: s_balances[msg.sender],\n                required: _value\n            });\n        s_balances[msg.sender] -= _value;\n        s_balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public returns (bool success) {\n        if (_to == address(0)) revert EnergyMarket__InvalidAddress(_to);\n        if (_value > s_balances[_from])\n            revert EnergyMarket__InsufficientBalance({\n                balance: s_balances[_from],\n                required: _value\n            });\n        if (_value > s_allowed[_from][msg.sender])\n            revert EnergyMarket__InsufficientAllowance({\n                allowance: s_allowed[_from][msg.sender],\n                required: _value\n            });\n        s_balances[_from] -= _value;\n        s_balances[_to] += _value;\n        s_allowed[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    ) public returns (bool success) {\n        s_allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) public view returns (uint256 remaining) {\n        return s_allowed[_owner][_spender];\n    }\n\n    function increaseAllowance(\n        address _spender,\n        uint256 _addedValue\n    ) public returns (bool success) {\n        s_allowed[msg.sender][_spender] += _addedValue;\n        emit Approval(msg.sender, _spender, s_allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    function decreaseAllowance(\n        address _spender,\n        uint256 _subtractedValue\n    ) public returns (bool success) {\n        uint256 oldValue = s_allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            s_allowed[msg.sender][_spender] = 0;\n        } else {\n            s_allowed[msg.sender][_spender] = oldValue - _subtractedValue;\n        }\n        emit Approval(msg.sender, _spender, s_allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    function mint(address _to, uint256 _value) public returns (bool success) {\n        if (msg.sender != i_DSO) revert EnergyMarket__NotDSO(msg.sender);\n        s_totalSupply += _value;\n        s_balances[_to] += _value;\n        emit Transfer(address(0), _to, _value);\n        return true;\n    }\n\n    function burn(address _from, uint256 _value) public returns (bool success) {\n        if (msg.sender != i_DSO) revert EnergyMarket__NotDSO(msg.sender);\n        if (_value > s_balances[_from])\n            revert EnergyMarket__InsufficientBalance({\n                balance: s_balances[_from],\n                required: _value\n            });\n        s_totalSupply -= _value;\n        s_balances[_from] -= _value;\n        emit Transfer(_from, address(0), _value);\n        return true;\n    }\n\n    // Enum\n    enum EnergyState {\n        Register, // 0\n        Injected, // 1\n        Board, // 2\n        Match, // 3\n        Purchased // 4\n    }\n\n    // State Variables\n    uint256 private s_totalEnergySupplied;\n    uint256 private s_totalEnergyDemanded;\n    uint256 private s_totalUsers;\n    uint256 private s_startTime;\n    uint256 private s_endTime;\n    uint256 private s_supplyIndex;\n    uint256 private s_demandIndex;\n    uint256 public constant MAX_ENERGYPRICE = 50;\n\n    // Structures\n    struct EnergyOwnership {\n        address addrOwner;\n        uint256 energyAmount;\n        uint256 energyState;\n        uint256 timestamp;\n    }\n    struct Supply {\n        address addrProsumer;\n        uint256 energySupplied;\n    }\n    struct Demand {\n        address addrConsumer;\n        uint256 energyDemanded;\n    }\n    struct EnergyMatched {\n        address addrProsumer;\n        address addrConsumer;\n        uint256 energyAmount;\n        uint256 timestamp;\n    }\n\n    // Mappings\n    mapping(address => uint256) private s_addrIndex;\n\n    // Arrays\n    EnergyOwnership[][] private s_energys;\n    EnergyOwnership[] private s_energy;\n    Supply[] private s_supplies;\n    Demand[] private s_demands;\n    EnergyMatched[] private s_matches;\n\n    // Events\n    event Gen(uint256 gen);\n    event EnergyCheck(\n        address addrOwner,\n        uint256 energyAmount,\n        uint256 energyState,\n        uint256 timestamp\n    );\n    event RoundStart(uint256 startTime, uint256 endTime);\n    event SellRequestCheck(address addr, uint256 amount);\n    event BuyRequestCheck(address addr, uint256 amount);\n    event EnergyMatchedCheck(\n        address addrProsumer,\n        address addrConsumer,\n        uint256 value,\n        uint256 timestamp\n    );\n\n    // Functions\n\n    // Getter functions\n    function getDSO() public view returns (address) {\n        return i_DSO;\n    }\n\n    function getTotalEnergySupplied() public view returns (uint256) {\n        return s_totalEnergySupplied;\n    }\n\n    function getTotalEnergyDemanded() public view returns (uint256) {\n        return s_totalEnergyDemanded;\n    }\n\n    function getTotalUsers() public view returns (uint256) {\n        return s_totalUsers;\n    }\n\n    function getStartTime() public view returns (uint256) {\n        return s_startTime;\n    }\n\n    function getEndTime() public view returns (uint256) {\n        return s_endTime;\n    }\n\n    function getIndexFromAddress(address _addr) public view returns (uint256) {\n        return s_addrIndex[_addr];\n    }\n\n    // function getEnergyOwnershipInfo(\n    //     address _addr\n    // ) public view returns (EnergyOwnership[] memory, uint256) {\n    //     return (\n    //         s_energys[s_addrIndex[_addr]],\n    //         s_energys[s_addrIndex[_addr]].length\n    //     );\n    // }\n\n    function getEnergyOwnershipInfo(\n        address _addr,\n        uint256 _index\n    ) public view returns (EnergyOwnership memory) {\n        return s_energys[s_addrIndex[_addr]][_index];\n    }\n\n    function getSupplyIndex() public view returns (uint256) {\n        return s_supplyIndex;\n    }\n\n    function getSupplyInfo(uint256 _index) public view returns (Supply memory) {\n        return s_supplies[_index];\n    }\n\n    function getDemandIndex() public view returns (uint256) {\n        return s_demandIndex;\n    }\n\n    function getDemandInfo(uint256 _index) public view returns (Demand memory) {\n        return s_demands[_index];\n    }\n\n    function getMatchInfo(\n        uint256 _index\n    ) public view returns (EnergyMatched memory) {\n        return s_matches[_index];\n    }\n\n    // Register function\n    function register() public {\n        s_addrIndex[msg.sender] = s_totalUsers;\n        EnergyOwnership memory _energy = EnergyOwnership(\n            msg.sender,\n            0,\n            uint256(EnergyState.Register),\n            block.timestamp\n        );\n        s_energy.push(_energy);\n        s_energys.push(s_energy);\n\n        emit EnergyCheck(\n            msg.sender,\n            0,\n            uint256(EnergyState.Register),\n            _energy.timestamp\n        );\n        s_totalUsers++;\n        delete s_energy;\n    }\n\n    // Inject Energy (Ei)\n    function inject(address _owner, uint256 _amount) public {\n        if (msg.sender != i_DSO) revert EnergyMarket__NotDSO(msg.sender);\n        uint256 i = s_addrIndex[_owner];\n\n        EnergyOwnership memory _energy = EnergyOwnership(\n            _owner,\n            _amount,\n            uint256(EnergyState.Injected),\n            block.timestamp\n        );\n        s_energys[i].push(_energy);\n        uint256 j = s_energys[i].length - 1;\n\n        emit EnergyCheck(\n            _owner,\n            _amount,\n            uint256(EnergyState.Injected),\n            _energy.timestamp\n        );\n\n        // Aggregation\n        if (j != 1) {\n            s_energys[i][1].energyAmount += s_energys[i][j].energyAmount;\n            s_energys[i][1].timestamp = block.timestamp;\n            s_energys[i].pop();\n        }\n        emit Gen(0);\n    }\n\n    // Start Round\n    function roundStart() public {\n        if (msg.sender != i_DSO) revert EnergyMarket__NotDSO(msg.sender);\n        s_startTime = block.timestamp;\n        s_endTime = s_startTime + 1 hours;\n        s_totalEnergyDemanded = 0;\n        s_totalEnergySupplied = 0;\n        emit RoundStart(s_startTime, s_endTime);\n    }\n\n    // Request to sell amount of intent to sell (Si)\n    function requestSell(uint256 _amount) public {\n        uint256 i = s_addrIndex[msg.sender];\n        uint256 injectedEnergy = s_energys[i][1].energyAmount;\n        if (injectedEnergy < _amount)\n            revert EnergyMarket__InsufficientEnergyInjected({\n                energyAmount: injectedEnergy,\n                required: _amount\n            });\n        if (block.timestamp > s_endTime)\n            revert EnergyMarket__OutsideRound(\n                block.timestamp,\n                s_startTime,\n                s_endTime\n            );\n\n        EnergyOwnership memory _energy = EnergyOwnership(\n            msg.sender,\n            _amount,\n            uint256(EnergyState.Board),\n            block.timestamp\n        );\n        s_energys[i].push(_energy);\n        s_energys[i][1].energyAmount = injectedEnergy - _amount;\n\n        emit EnergyCheck(\n            msg.sender,\n            _amount,\n            uint256(EnergyState.Board),\n            _energy.timestamp\n        );\n\n        Supply memory _supply = Supply(msg.sender, _amount);\n        s_supplies.push(_supply);\n        s_supplyIndex++;\n        s_totalEnergySupplied += _amount;\n\n        emit SellRequestCheck(msg.sender, _amount);\n    }\n\n    // Request to buy amount of intent to buy (Di)\n    function requestBuy(uint256 _amount) public {\n        if (_amount == 0) revert EnergyMarket__ZeroEnergyAmount();\n        if (block.timestamp > s_endTime)\n            revert EnergyMarket__OutsideRound(\n                block.timestamp,\n                s_startTime,\n                s_endTime\n            );\n        uint256 balance = balanceOf(msg.sender);\n        uint256 maxPrice = _amount * MAX_ENERGYPRICE;\n        if (maxPrice > balance)\n            revert EnergyMarket__InsufficientBalance({\n                balance: balance,\n                required: maxPrice\n            });\n\n        uint256 i = s_addrIndex[msg.sender];\n        EnergyOwnership memory _energy = EnergyOwnership(\n            msg.sender,\n            _amount,\n            uint256(EnergyState.Board),\n            block.timestamp\n        );\n        s_energys[i].push(_energy);\n\n        emit EnergyCheck(\n            msg.sender,\n            _amount,\n            uint256(EnergyState.Board),\n            _energy.timestamp\n        );\n\n        Demand memory demand = Demand(msg.sender, _amount);\n        s_demands.push(demand);\n        s_demandIndex++;\n        s_totalEnergyDemanded += _amount;\n\n        decreaseAllowance(i_DSO, balance);\n        approve(i_DSO, maxPrice);\n\n        emit BuyRequestCheck(msg.sender, _amount);\n    }\n\n    // Match\n    function matching() public {\n        if (msg.sender != i_DSO) revert EnergyMarket__NotDSO(msg.sender);\n        // Setting endTime of round to when the matching() function is called\n        s_endTime = block.timestamp;\n\n        // Local Variables for gas optimization\n        uint256 totalSupplyOfEnergy = s_totalEnergySupplied;\n        uint256 totalDemandOfEnergy = s_totalEnergyDemanded;\n        uint256 supplyIndex = s_supplyIndex;\n        uint256 demandIndex = s_demandIndex;\n\n        // q - Demand/Supply Ratio\n        uint256 q = 1;\n        uint256 matchedSupplyIndex;\n        uint256 matchedDemandIndex;\n\n        if (totalSupplyOfEnergy > totalDemandOfEnergy) {\n            q = (totalDemandOfEnergy * 100) / totalSupplyOfEnergy;\n\n            // Setting matched (actually sold) energy (Smi)\n            for (uint256 i = 0; i < supplyIndex; i++) {\n                Supply memory _supply = s_supplies[i];\n                s_supplies[i].energySupplied =\n                    (_supply.energySupplied * q) /\n                    100;\n\n                uint256 addr_i = s_addrIndex[_supply.addrProsumer];\n                uint256 j = s_energys[addr_i].length - 1;\n                uint256 energyAmount = s_energys[addr_i][j].energyAmount;\n\n                s_energys[addr_i][1].energyAmount +=\n                    energyAmount -\n                    (energyAmount * q) /\n                    100;\n                s_energys[addr_i][1].timestamp = block.timestamp;\n                s_energys[addr_i][j].energyAmount = (energyAmount * q) / 100;\n                s_energys[addr_i][j].energyState = uint256(EnergyState.Match);\n                s_energys[addr_i][j].timestamp = block.timestamp;\n            }\n        } else if (totalSupplyOfEnergy < totalDemandOfEnergy) {\n            q = (totalSupplyOfEnergy * 100) / totalDemandOfEnergy;\n\n            // Setting matched (actually bought) energy (Dmi)\n            for (uint256 i = 0; i < demandIndex; i++) {\n                Demand memory _demand = s_demands[i];\n                uint256 addr_i = s_addrIndex[_demand.addrConsumer];\n                s_demands[i].energyDemanded =\n                    (_demand.energyDemanded * q) /\n                    100;\n                s_energys[addr_i][1].energyAmount = _demand.energyDemanded;\n                s_energys[addr_i][1].energyState = uint256(EnergyState.Match);\n                s_energys[addr_i][1].timestamp = block.timestamp;\n            }\n        }\n\n        // Getting each supply and demand to match\n        Supply memory supply = s_supplies[matchedSupplyIndex];\n        Demand memory demand = s_demands[matchedDemandIndex];\n\n        // Matching\n        do {\n            if (supply.energySupplied > demand.energyDemanded) {\n                // Matching demand.energyDemanded of energy\n                supply.energySupplied -= demand.energyDemanded;\n                EnergyMatched memory _match = EnergyMatched(\n                    supply.addrProsumer,\n                    demand.addrConsumer,\n                    demand.energyDemanded,\n                    block.timestamp\n                );\n                s_matches.push(_match);\n                emit EnergyMatchedCheck(\n                    _match.addrProsumer,\n                    _match.addrConsumer,\n                    _match.energyAmount,\n                    _match.timestamp\n                );\n                matchedDemandIndex++;\n                if (matchedDemandIndex >= demandIndex) break;\n                demand = s_demands[matchedDemandIndex];\n            } else if (supply.energySupplied < demand.energyDemanded) {\n                // Matching supply.energySupplied of energy\n                demand.energyDemanded -= supply.energySupplied;\n                EnergyMatched memory _match = EnergyMatched(\n                    supply.addrProsumer,\n                    demand.addrConsumer,\n                    supply.energySupplied,\n                    block.timestamp\n                );\n                s_matches.push(_match);\n                emit EnergyMatchedCheck(\n                    _match.addrProsumer,\n                    _match.addrConsumer,\n                    _match.energyAmount,\n                    _match.timestamp\n                );\n                matchedSupplyIndex++;\n                if (matchedSupplyIndex >= supplyIndex) break;\n                supply = s_supplies[matchedSupplyIndex];\n            } else {\n                // Matching equal energy\n                EnergyMatched memory _match = EnergyMatched(\n                    supply.addrProsumer,\n                    demand.addrConsumer,\n                    supply.energySupplied,\n                    block.timestamp\n                );\n                s_matches.push(_match);\n                emit EnergyMatchedCheck(\n                    _match.addrProsumer,\n                    _match.addrConsumer,\n                    _match.energyAmount,\n                    _match.timestamp\n                );\n                matchedSupplyIndex++;\n                matchedDemandIndex++;\n                if (matchedSupplyIndex >= supplyIndex) break;\n                if (matchedDemandIndex >= demandIndex) break;\n                supply = s_supplies[matchedSupplyIndex];\n                demand = s_demands[matchedDemandIndex];\n            }\n        } while (true);\n\n        uint256 userCount = s_totalUsers;\n        for (uint256 i = 0; i < userCount; i++) {\n            uint256 maxLen = s_energys[i].length;\n            for (uint256 j = maxLen - 1; j > 1; j--) {\n                if (s_energys[i][j].energyAmount == 0) {\n                    for (uint256 k = j; k < maxLen - 1; k++) {\n                        s_energys[i][k] = s_energys[i][k + 1];\n                    }\n                    s_energys[i].pop();\n                }\n            }\n        }\n\n        emit Gen(0);\n    }\n\n    // Trade\n    function trade(uint256 _price) public {\n        if (msg.sender != i_DSO) revert EnergyMarket__NotDSO(msg.sender);\n        uint256 price = _price;\n\n        uint256 matchesLen = s_matches.length;\n        for (uint256 i = 0; i < matchesLen; i++) {\n            EnergyMatched memory _match = s_matches[i];\n            uint256 index = s_addrIndex[_match.addrConsumer];\n            transferFrom(\n                _match.addrConsumer,\n                _match.addrProsumer,\n                _match.energyAmount * price\n            );\n            s_energys[index][1].energyAmount = _match.energyAmount;\n            s_energys[index][1].energyState = uint256(EnergyState.Purchased);\n            s_energys[index][1].timestamp = block.timestamp;\n        }\n\n        delete s_matches;\n        emit Gen(0);\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}